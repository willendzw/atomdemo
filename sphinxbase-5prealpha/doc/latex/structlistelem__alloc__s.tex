\section{listelem\+\_\+alloc\+\_\+s Struct Reference}
\label{structlistelem__alloc__s}\index{listelem\+\_\+alloc\+\_\+s@{listelem\+\_\+alloc\+\_\+s}}


Fast linked list allocator.  


\subsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
\mbox{\label{structlistelem__alloc__s_a2c3be8623c5bb2d4afb3ad888790a4eb}} 
char $\ast$$\ast$ \textbf{ freelist}
\begin{DoxyCompactList}\small\item\em ptr to first element in freelist \end{DoxyCompactList}\item 
\textbf{ glist\+\_\+t} \textbf{ blocks}
\begin{DoxyCompactList}\small\item\em Linked list of blocks allocated. \end{DoxyCompactList}\item 
\mbox{\label{structlistelem__alloc__s_ada7b3fcd2f878e67e07e4bb185bb3015}} 
\textbf{ glist\+\_\+t} \textbf{ blocksize}
\begin{DoxyCompactList}\small\item\em Number of elements in each block. \end{DoxyCompactList}\item 
\mbox{\label{structlistelem__alloc__s_a9e27c7163c45a43f8dfd667cbc014f49}} 
size\+\_\+t \textbf{ elemsize}
\begin{DoxyCompactList}\small\item\em Number of (char $\ast$) in element. \end{DoxyCompactList}\item 
\mbox{\label{structlistelem__alloc__s_ab96fd1e097105a34d6ae2e79ae8e2520}} 
size\+\_\+t \textbf{ blk\+\_\+alloc}
\begin{DoxyCompactList}\small\item\em Number of alloc operations before increasing blocksize. \end{DoxyCompactList}\item 
\mbox{\label{structlistelem__alloc__s_a90c7d399a72d00cdb476bd5f518b4711}} 
size\+\_\+t {\bfseries n\+\_\+blocks}
\item 
\mbox{\label{structlistelem__alloc__s_a2a2fa0a7a1e03d6aee2f685dbc1db774}} 
size\+\_\+t {\bfseries n\+\_\+alloc}
\item 
\mbox{\label{structlistelem__alloc__s_adde313f665b6f2be9ea22f4d209e576d}} 
size\+\_\+t {\bfseries n\+\_\+freed}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Fast linked list allocator. 

We keep a separate linked list for each element-\/size. Element-\/size must be a multiple of pointer-\/size.

Initially a block of empty elements is allocated, where the first machine word in each element points to the next available element. To allocate, we use this pointer to move the freelist to the next element, then return the current element.

The last element in the list starts with a N\+U\+LL pointer, which is used as a signal to allocate a new block of elements.

In order to be able to actually release the memory allocated, we have to add a linked list of block pointers. This shouldn\textquotesingle{}t create much overhead since we never access it except when freeing the allocator. 

Definition at line 65 of file listelem\+\_\+alloc.\+c.



\subsection{Field Documentation}
\mbox{\label{structlistelem__alloc__s_a1216578b1d5416dc0a03c802cfa1def9}} 
\index{listelem\+\_\+alloc\+\_\+s@{listelem\+\_\+alloc\+\_\+s}!blocks@{blocks}}
\index{blocks@{blocks}!listelem\+\_\+alloc\+\_\+s@{listelem\+\_\+alloc\+\_\+s}}
\subsubsection{blocks}
{\footnotesize\ttfamily \textbf{ glist\+\_\+t} listelem\+\_\+alloc\+\_\+s\+::blocks}



Linked list of blocks allocated. 



Definition at line 67 of file listelem\+\_\+alloc.\+c.



Referenced by listelem\+\_\+get\+\_\+item(), and listelem\+\_\+stats().



The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/libsphinxbase/util/listelem\+\_\+alloc.\+c\end{DoxyCompactItemize}
